/*
  Copyright 2019 Google LLC

  Use of this source code is governed by an MIT-style
  license that can be found in the LICENSE file or at
  https://opensource.org/licenses/MIT.
*/

import {assert} from 'workbox-core/_private/assert.js';
import {cacheNames} from 'workbox-core/_private/cacheNames.js';
import {logger} from 'workbox-core/_private/logger.js';
import {WorkboxError} from 'workbox-core/_private/WorkboxError.js';
import {waitUntil} from 'workbox-core/_private/waitUntil.js';
import {Strategy} from 'workbox-strategies/Strategy.js';
import {RouteHandlerCallback, WorkboxPlugin} from 'workbox-core/types.js';

import {createCacheKey} from './utils/createCacheKey.js';
import {PrecacheInstallReportPlugin} from './utils/PrecacheInstallReportPlugin.js';
import {PrecacheCacheKeyPlugin} from './utils/PrecacheCacheKeyPlugin.js';
import {printCleanupDetails} from './utils/printCleanupDetails.js';
import {printInstallDetails} from './utils/printInstallDetails.js';
import {PrecacheStrategy} from './PrecacheStrategy.js';
import {PrecacheEntry, InstallResult, CleanupResult} from './_types.js';
import './_version.js';

// Give TypeScript the correct global.
declare let self: ServiceWorkerGlobalScope;

declare global {
  interface ServiceWorkerGlobalScope {
    __WB_MANIFEST: Array<PrecacheEntry | string>;
  }
}

interface PrecacheControllerOptions {
  cacheName?: string;
  plugins?: WorkboxPlugin[];
  fallbackToNetwork?: boolean;
}

/**
 * Performs efficient precaching of assets.
 *
 * @memberof workbox-precaching
 */
class PrecacheController {
  private _installAndActiveListenersAdded?: boolean;
  private readonly _strategy: Strategy;
  private readonly _urlsToCacheKeys: Map<string, string> = new Map();
  private readonly _urlsToCacheModes: Map<
    string,
    | 'reload'
    | 'default'
    | 'no-store'
    | 'no-cache'
    | 'force-cache'
    | 'only-if-cached'
  > = new Map();
  private readonly _cacheKeysToIntegrities: Map<string, string> = new Map();

  /**
   * Create a new PrecacheController.
   *
   * @param {Object} [options]
   * @param {string} [options.cacheName] The cache to use for precaching.
   * @param {string} [options.plugins] Plugins to use when precaching as well
   * as responding to fetch events for precached assets.
   * @param {boolean} [options.fallbackToNetwork=true] Whether to attempt to
   * get the response from the network if there's a precache miss.
   */
  constructor({
    cacheName,
    plugins = [],
    fallbackToNetwork = true,
  }: PrecacheControllerOptions = {}) {
    this._strategy = new PrecacheStrategy({
      cacheName: cacheNames.getPrecacheName(cacheName),
      plugins: [
        ...plugins,
        new PrecacheCacheKeyPlugin({precacheController: this}),
      ],
      fallbackToNetwork,
    });

    // Bind the install and activate methods to the instance.
    this.install = this.install.bind(this);
    this.activate =